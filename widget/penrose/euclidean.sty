-- inspired by https://github.com/penrose/penrose/blob/499cd21f39549abd317976f492b803a09ce2277d/packages/examples/src/geometry-domain/euclidean-teaser.style

layout = [shape, label]

Colors {
  -- Keenan palette
  black = #000000
  white = #fff
  darkpurple = #8c90c1
  lightpurple = #d0d3e6
  purple2 = rgba(0.106, 0.122, 0.54, 0.2)
  verylightpurple = rgba(0.953, 0.957, 0.977, 1.0)
  purple3 = rgba(0.557, 0.627, 0.769, 1.0)
  midnightblue = rgba(0.14, 0.16, 0.52, 1.0)
  none = none()
}


const {
  strokeWidth = 1.75
  textPadding = 0.1
  repelWeight = 0.3
  pointRadius = 4.0
  minCircleRadius = 50.0
  maxCircleRadius = 250.0
}


-- Point
forall Point p {
  p.vec = (? in shape, ? in shape)

  p.icon = Circle {
    center: p.vec
    r : const.pointRadius
    fillColor : theme.foreground
    strokeWidth : const.strokeWidth
    strokeColor : theme.tooltipBorder
  }

  p.textBox = Rectangle {
    fillColor : Colors.none
    cornerRadius : 5
  }

  ensure equal(signedDistance(p.textBox, p.vec), const.textPadding) in label
  p.textLayering = p.textBox above p.icon
}


-- Line
forall Line L {
  L.color = theme.foreground

  L.icon = Line {
    start : (? in shape, ? in shape)
    end : (? in shape, ? in shape)
    strokeColor : L.color
    strokeWidth : const.strokeWidth
    style : "solid"
  }

  L.textBox = Rectangle {
    fillColor : Colors.none
    cornerRadius : 5
  }

  ensure equal(signedDistance(L.textBox, L.icon.start), const.textPadding) in label
  ensure disjoint(L.textBox, L.icon) in label
}

-- Circle
forall Circle C {
  C.radius = ? in shape
  C.center = (? in shape, ? in shape)

  C.icon = Circle {
    center : C.center
    r : C.radius
    strokeWidth : const.strokeWidth
    strokeColor : theme.foreground
    fillColor : Colors.none
  }

  C.textBox = Rectangle {
    fillColor : Colors.none
    cornerRadius : 5
  }

  ensure touching(C.icon, C.textBox) in label
  encourage lessThan(const.minCircleRadius, C.radius) in shape
  encourage lessThan(C.radius, const.maxCircleRadius) in shape
}

-- Point on Line
forall Point p; Line L
where OnLine(p, L) {
  ensure containsPolyPoint([L.icon.start, L.icon.end], p.icon.center) in shape
}


-- Between
forall Point p, q, r
where Between(p, q, r) {
  ensure collinearOrdered(p.icon.center, q.icon.center, r.icon.center) in shape
  encourage notTooClose(p.icon, q.icon, const.repelWeight) in label
  encourage notTooClose(q.icon, r.icon, const.repelWeight) in label
}

-- Point on Circle
forall Point p; Circle C
where OnCircle(p, C) {
  ensure equal(signedDistance(C.icon, p.vec), 0) in shape
  -- containsCirclePoint seems buggy for multiple circles
  ensure disjoint(C.textBox, p.icon) in label
  }

-- Point as Circle center
forall Point p; Circle C
where CenterCircle(p, C) {
  ensure equal(C.center[0], p.vec[0]) in shape
  ensure equal(C.center[1], p.vec[1]) in shape
  ensure disjoint(C.textBox, p.icon) in label
}

-- Repelling
forall Point p; Line L {
  ensure disjoint(p.textBox, L.textBox) in label
  p.icon above L.icon
}

forall Line L; Line M {
  ensure disjoint(L.textBox, M.textBox)
}

forall Point p; Point q {
  ensure disjoint(p.textBox, q.textBox)
  encourage notTooClose(p.icon, q.icon, const.repelWeight)
}

forall Point p; Circle C {
  ensure disjoint(p.textBox, C.textBox)
  ensure disjoint(p.icon, C.textBox)
  p.icon above C.icon
}

forall Line L; Circle C {
  ensure disjoint(L.textBox, C.textBox)
  ensure disjoint(L.icon, C.textBox)
  encourage notTooClose(L.textBox, C.textBox, const.repelWeight)
  encourage notTooClose(L.icon, C.textBox, const.repelWeight)
}

forall Circle C; Circle D {
  encourage notTooClose(C.textBox, D.textBox, const.repelWeight)
  encourage notTooClose(C.textBox, D.icon, const.repelWeight)
  encourage notTooClose(C.icon, D.icon, const.repelWeight)
  ensure disjoint(C.textBox, D.icon)
}
